01 РЕВЬЮ ПП
Вопросы:
## Q
1. Что такое Maven? Для чего он нужен? Как добавлять в проект библиотеки без него?
## A
при работе с любыми классами, необходимо сделать классы доступными для компилятора и
рабочего окружения. Сконфигурируйте переменную окружения CLASPATH или скопируйте
соответствующий JAR-файл со всеми его классами в директорию $JAVA_HOME/jre/lib/ext,
расположенную в основной инсталляционной директории Java 2 Platform (J2SE).
Главное преимущество Maven — это управление зависимостями. Редко какие проекты пишутся без использования сторонних библиотек. Эти сторонние библиотеки зачастую тоже в свою очередь используют библиотеки разных версий. Maven позволяет управлять такими
==сложными зависимостями, что позволяет разрешать конфликты версий и в случае
необходимости легко переходить на новые версии библиотек. ==
Добавить самому - project structure - Libraries
Maven - система управления жизненным циклом проекта. Это инструмент стандартизации
сборки и дальнейшего развертывания проекта, а так же управлением зависимостями.
Предназначен для создания документации, автоматической загрузки зависимостей и
автоматической сборки проектов, написанных на Java, Groovy и др. языках. Это фреймворк
для создания проектов с большим количеством шаблонов структур проекта и фреймворков.

В зависимости от архетипа будут созданы проекты с разной иерархией файлов и папок.
Создавать сложные проекты вручную это громоздко, долго и неудобно. Сейчас в целях
стандартизации сборки и дальнейшего развертывания используются специальные
инструменты типа Maven. Одна из вещей, которую Maven стандартизировал в первую очередь,
— это описание проекта. До Maven у каждой IDE был свой project-файл, который хранил
информацию о проекте и его сборке (и зачастую в бинарном виде).
Maven предложил универсальный открытый стандарт на основе XML, в котором с помощью
различных тегов описывается, что это за проект, как его нужно собирать и какие у него
зависимости. Вся необходимая информация о проекте заключена в одном файле, обычно с
именем pom.xml.
До Мавена сборка проекта происходила посредством скрипта в баше или шелле, который
представлял собой последовательность команд. Подтягивание зависимостей было очень
грустное- скачивался JAR-ник с каких-т ресурсов, через Project Structure -> Dependencies ->
добавление этого джарника импортировалась библиотека.
## Q
2. Как добавить dependency в Maven? Для чего они
нужны? Откуда они скачиваются?
## A
Артефакт (от лат. artefactum – искусственно сделанное) – любая библиотека, результат
сборки проекта. Это элемент, который Maven может либо использовать, либо создать. Могут
быть разных типов jar, war, zip, swf.
В стандарте Maven артефактом можно назвать как программу, так и проект, модуль,
библиотеку и тому подобное.
У любого артефакта есть координаты - уникальный набор, состоящий из версии,
упаковки, идентификаторы группы и идентификатора артефакта:
Group Id - ключ, ускоряющий организацию и поиск проекта. Это параметр, указывающий
группу или отдельное лицо, создавшее проект, который часто является обратным
доменным именем компании. В качестве groupid обычно выступает имя верхнего пакета
проекта.

Artifact Id - это базовое имя проекта(уникальный строковый идентификатор), по умолчанию
используется в качестве конечного имени артефакта. Это идентификатор, позволяющий
выделить данный проект среди проектов с одинаковым groupId. Наилучшей практикой
считается использование фактического названия проекта в качестве префикса. Это
упрощает поиск артефактов.

Version - версия проекта, все проекты, которые были выпущены, имеют версию. Проекты в
стадии активной разработки могут иметь специдентификатор SNAPSHOT.

packaging - тип упаковки проекта. По умолчанию используется jar. 
- Проект с упаковкой jar собирается в JAR - архив. 
- Проект с упаковкой war собирается в WAR - архив(веб-приложения). 
Этот элемент используется для указания типа артефакта, сгенерированного проектом. Упаковкой может быть что угодно, описывающее любой двоичный формат программного обеспечения, включая ZIP, EAR, WAR, SWC, NAR, SWF, SAR.

Репозиторий - это хранилище артефактов.

Есть три вида репозиториев:
локальный - директория на диске, содержащая дерево каталогов артефактов(место на
компуктере, где хранятся библиотеки). Во время сборки проекта артефакты должны
находиться в локальном репозитории. Если каких-то артефактов нет, они подгружаются с
других репозиториев.

Центральный - находится по адресу http://repo1.maven.org/maven2 . Но для просмотра и
загрузки его содержимого через браузер следует использовать http://search.maven.org/ .
удаленный - сервер, с которого загружаются артефакты. По сути центральный
репозиторий частный случай удаленного.

Следующая фишка Maven - управление зависимостями. Для того, чтобы добавить какую-
либо библиотеку в наш проект, необходимо просто прописать dependency в pom.xml - файле.
допустим, для того ,чтобы добавить в наш проект последние версии Spring и Hibernate,
необходимо сделать следующее:

Все, более никаких действий не требуется. Теперь мы можем пользоваться классами
указанных библиотек, и что самое главное, если залить проект на GitHub или переслать кому-то в виде архива, человек по ту сторону гарантированно сможет его собрать, поскольку вся
информация по зависимостям, библиотекам и сценариям сборки уже зашита в проект.
Зависимости которые мы подключаем - по факту программы Java, которые писали другие люди
и указывали groupId и artifactId, которые мы указываем при создании проекта Maven.

Во время сборки Maven будет искать указанную библиотеку(артефакт) в локальном
репозитории .
Если в локальном репозитории ее не обнаружится, он будет проводить поиск в центральном
глобальном Maven - репозитории, а затем загрузит его в твой локальный репозиторий для
ускорения сборки в дальнейшем.

WAR - это сжатый архив, содержащий все необходимые файлы и ресурсы для развертывания веб-приложения. Он является стандартным форматом развертывания для Java веб-приложений и может быть развернут на сервере приложений, таком как Apache Tomcat или JBoss.
WAR Exploded - это развернутое представление веб-приложения, где файлы и ресурсы из WAR-архива распаковываются в файловую систему сервера приложений. Вместо запуска веб-приложения непосредственно из архива WAR, сервер приложений работает с файлами и ресурсами в развернутом виде.

Основное отличие между этими двумя форматами заключается в том, что в случае WAR-архива веб-приложение хранится в одном сжатом файле, который может быть развернут на сервере приложений. В случае WAR Exploded, файлы и ресурсы веб-приложения уже развернуты в файловой системе сервера приложений.
## Q
3. Основные фазы проекта под управлением Maven?
## A
Жизненный цикл сборки в Maven – это чётко определённая последовательность фаз во время
выполнения которых должны быть достигнуты определённые цели. Периоды жизненного цикла
проекта и что они делают:
I. Prepare-resources(Копирование ресурсов):
"clean" в Lifecycl'e удалит папку target со скомпилированным кодом.
"validate" провалидирует наш проект на корректность, полноту информации. Показывает,
можно ли его скомпилировать. Проверяет корректность метаинформации о проекте
II. Compile(компиляция):
"compile" скомпилирует код.
"test"- прогоняет тесты классов из предыдущего шага.
III. Package(Создание пакета):
"package" - упакует скомпилированный код в JAR-ник или какой-то другой тип.
"verify" - проверяет корректность артефакта и удовлетворение требованиям качества.
IV. Install(Установка):
"install" - перенесет проект в локальный репозиторий, из которого уже можно будет
работать с какими-то другими проектами.
"site" - предназначен для создания документации.
"deploy" - размещение проекта в удаленном репозитории.
clean и site. clean используется для того, чтобы полностью очистить папку target, а site
умеет создавать документацию проекта.
## Q
4. Что такое JDBC? Какие классы/интерфейсы относятся к JDBC?
## A
JDBC API - стандартный прикладной интерфейс Java, обесепчивающий взаимодействие
приложения с СУБД. Это платформенно- независимый стандарт взаимодействия с
реляционными БД, реализованный в Java в пакете java.sql(JDBC API). Является самым низкоуровневым API взаимодействия с СУБД, обладающим низким уровнем автоматизации и
абстракции.
Здесь мы сами делаем запросы и сами переводим объекты Java в строки таблицы.
JDBC основан на концепции драйверов, которые позволяют получать соединение с базой
данных по специально описанному URL. При загрузке драйвер регистрирует себя в системе и в дальнейшем автоматически вызывается, когда программа требует URL, содержащий протокол, за который этот драйвер отвечает.

Помимо того, что он имеет низкий уровень абстракции и все делается "вручную", при наличии ошибки, будет выбрасывать SQLException, т.е. сложно понять, в чем проблема.
JDBC решает следующие задачи:
JDBC – Java DataBase Connectivity – соединение с базами данных на Java. Это стандарт
взаимодействия с БД. Его интерфейс поставляется в стандартной JDK в виде
пакета java.sql. Какой бы библиотекой для работы с базой данных вы ни пользовались, в ее
основе почти всегда лежит низкоуровневый JDBC. Создание соединения с БД.
Создание SQL выражений.
Выполнение SQL – запросов.
Просмотр и модификация полученных записей
В JDBC есть 3 основных интерфейса:
Connection – отвечает за соединение с базой данных. Интерфейс Connection представляет
сессию соединения с базой данных, обеспечиваемую драйвером. Он также обеспечивает
методы для создания выражений, управления соединениями и их свойствами.
Statement – отвечает за запрос к базе данных
ResultSet – отвечает за результат запроса к базе данных

Интерфейс (ResultSetMetaData) - определяет объект метаданных для текущего набора данных ResultSet.

ResultSetMetaData содержит информацию о результирующей таблице - количество колонок, тип значений колонок и т.д. Интерфейс (DatabaseMetaData) - содержит методы, описывающие таблицы базы данных, поддержку SQL, хранимые процедуры и другие сведения, относящиеся к базе данных и текущему Connection, которые не относятся непосредственно к выполнению команд и извлечению результирующих наборов.
Существует два интерфейса подключения к БД:
Через DriverManager
Через DataSource
## Q
5. Для чего нужен DriverManager?
## A
Java-приложение и база данных общаются друг с другом посредством библиотеки, которая
называется JDBC Driver Это набор классов, которые реализуют JDBC API для конкретной
СУБД.
Драйвер отображает JDBC-команды на используемую вами базу данных. Каждый запрос на
соединение требует соответствующего драйвера.
Правильный JDBC драйвер выбирается с помощью класса под названием DriverManager.
В приложении может быть зарегистрировано несколько разных драйверов. При загрузке
драйвер регистрирует себя в системе и в дальнейшем автоматически вызывается. При
соединении к базе, нужный выбирается исходя из URL соединения. Например,
для jdbc:mysql://localhost:3306/db_name будет использован MySQL JDBC.

Класс DriverManager является уровнем управления JDBC, отслеживает все доступные
драйверы и управляет установлением соединений между БД и соответствующим драйвером.
Он содержит список зарегистрированных в системе JDBC-драйверов и устанавливает
соединение с драйвером. Данный класс используется в основном для получения ссылки на
объект Connection посредством метода getConnection.
При вызове метода getConnection DriverManager попытается найти подходящий драйвер среди
тех, которые загружаются при инициализации, и тех, которые загружаются явно с
использованием того же загрузчика классов, что и текущее приложение.

Мы абстрагируемся от строения конкретной базы данных, а используем унифицированный
интерфейс, который един для всех.
getConnection(String url) Пытается установить соединение с URL-адресом заданной базы
данных.
getConnection(String url, Properties info) Пытается установить соединение с URL-адресом
заданной базы данных. Параметры: url – адрес в формате jdbc:subprotocol:subname, info –
список произвольных пар тег/значение типа String, передаваемых в качестве аргументов

соединения. Обычно должна быть включена хотя бы одна пара «имя
пользователя»/«пароль».
getConnection(String url, String user, String password) Пытается установить соединение с
URL-адресом заданной базы данных. Параметры: url – адрес в формате
jdbc:subprotocol:subname, user – пользователь базы данных, от имени которого
устанавливается соединение, password – пароль пользователя.
## Q
6. Что такое Statement, PreparedStatement,
CallableStatement?
## A
Statement - (объект для оператора JDBC) используется для отправки SQL-оператора на сервер
баз данных. Объект для оператора связан с объектом Connection и является объектом,
обрабатывающим взаимодействие между приложением и сервером баз(объект для оператора
JDBC).
1. Statement — используется для выполнения обычных запросов SQL. Вы не можете
передавать параметры SQL-запросу во время выполнения с помощью этого
интерфейса. Этот интерфейс предпочтительнее двух других интерфейсов, если вы
выполняете конкретный SQL-запрос только один раз.
2) PreparedStatement — используется для выполнения динамических или
параметризованных запросов SQL. Вы можете передать параметры SQL-запросу во время
выполнения, используя этот интерфейс. Рекомендуется использовать PreparedStatement,
если вы выполняете конкретный SQL-запрос несколько раз.
3) CallableStatement — используется для выполнения хранимых процедур.
Процедура хранения — это группа операторов SQL, которая инкапсулирует все запросы и
компилируется.
Хранимая процедура похожа на функцию или метод в классе, за исключением того, что она
находится в базе данных.
Некоторые из преимуществ PreparedStatement по сравнению с Statement:
1. PreparedStatement помогает нам предотвратить атаки с использованием SQL-инъекций,
поскольку он автоматически экранирует специальные символы.
2. PreparedStatement позволяет нам выполнять динамические запросы с вводом параметров.
3. PreparedStatement предоставляет различные типы методов установки для установки
входных параметров запроса.
4. PreparedStatement быстрее, чем Statement. Это становится более заметным, когда мы
повторно используем PreparedStatement или используем его методы пакетной обработки
для выполнения нескольких запросов.
5. PreparedStatement помогает нам писать объектно-ориентированный код с помощью
методов установки, тогда как с Statement мы должны использовать конкатенацию строк для
создания запроса. Если необходимо установить несколько параметров, написание запроса
с использованием конкатенации строк выглядит очень некрасиво и подвержено ошибкам.

.executeUpdate() - метод, вызываемый на объекте statement'a, позволяющий обновить таблицу,
к которой мы обращаемся.
Выполняет такие команды, как INSERT, UPDATE, DELETE, CREATE TABLE, DROP TABLE.
.executeQuery(SQL-запрос) - метод statement'a, выполняющий запрос к нашей базе данных и
возвращает объект типа ResultSet, который инкапсулирует результат SQL - запроса.
После этого нам надо вручную поместить данные, полученные в ResultSet'e, в наш Java объект
путем итерации ResultSet'a через цикл while, последовательно заполняя поля объекта с
помощью сеттеров значениями, полученными из колонок.
## Q
7. Что такое sql-injection?
## A
SQL инъекция — это один из самых доступных способов взлома сайта.
Большинство веб-форм не имеют механизмов, которые бы исключали ввод дополнительной
информации в поле. ==Это дает злоумышленникам возможность передать в базу данных
собственные запросы через поля ввода формы. Они могут использовать эту уязвимость в
разных преступных целях, начиная с кражи конфиденциальных данных и заканчивая
манипулированием сведениями в базе.
Внедрение SQL, в зависимости от типа используемой СУБД и условий внедрения, может дать
возможность атакующему выполнить произвольный запрос к базе данных (например,
прочитать содержимое любыхтаблиц, удалить, изменить или добавитьданные),
получить возможность чтения и/или записи локальных файлов и выполнения произвольных
команд на атакуемом сервере.
==Атака типа внедрения SQL может быть возможна из-за некорректной обработки входных
данных, используемых в SQL-запросах.
Суть таких инъекций – внедрение в данные (передаваемые через GET, POST запросы или
значения Cookie) произвольного SQL кода, то по сути есть возможность творить с БД (чаще
всего это MySQL) что угодно.
3 Как защититься от инъекций?

1) Шаг первый – тщательная проверка данных, присланных пользователем. Нужно проверить, является ли переменная числом. Можно выполнить принудительное преобразование переменной в число. Если злоумышленник подсунет в запрос строку, то она все равно станет числом. Со строковыми данными все будет немного по-другому. Здесь нам нужно удалить из запроса кавычки, начальные и конечные пробелы, а также теги (конечно, если всё это присутствует в строке).

2) Шаг второй – грамотная обработка ошибок. При подстановке в GET-запрос неверного параметра на странице может высветиться очень красноречивое для злоумышленника сообщение с информацией о структуре базы. Дабы такого не происходило, следует обработать возможные ошибки. К примеру, если статьи с переданным в GET-запросе id не существует, то можно вывести соответствующее сообщение. Либо просто перенаправить пользователя на другую страницу. Вариантов здесь масса.

3) Шаг третий – использование подготавливаемых запросов. Использовать так называемые prepared statements вместо обычных запросов. Их суть заключается в том, что сначала запрос подготавливается для приема параметров, затем происходит добавление параметров с указанием их типов (строка, число и т.д.), и только потом

– непосредственное выполнение.
Проверять нужно всё – числа, строки, даты, данные в специальных форматах.
## Q
8. Что такое ResultSet? Как с ним работать?
## A
ResultSet ,инкапсулирует результат SQL - запроса. Представляет результирущий набор
данных и обеспечивает приложению построчный доступ к результатам запросов. – чем-то
похож на итератор: он позволяет устанавливать/менять текущую строку результата, а
затем из этой текущей строки можно получить данные, т.е. обеспечивает приложению
построчный доступ к результатам запросов. При обработке запроса ResultSet
поддерживает указатель на текущую обрабатываемую строку. Ниже приведены методы
для работы со строкой.

Доступ к данным ResultSet** обеспечивает посредством набора get-методов, которые
организуют доступ к колонкам текущей строки. Метод ResultSet.next используется для
перемещения к следующей строке ResultSet, делая ее текущей.
Затем из текущей строки объекта ResultSet можно получить данные из его колонок:
getType(номерКолонки/имя колонки) - вытаскиваем данные соответствующего типа на
объекте ResultSet. Предпочтительнее работа с именами колонок.

Сколько методов, перемещающих курсор по ResultSet? (8 штук. Методы для навигации)

- next() — перемещает курсор на одну строку вперёд. Возвращает true, если перемещение удалось и false, если курсор уже находится за последней строкой.

- previous() — антоним next(). Перемещает курсор на одну строку назад и тоже возвращает true, если перемещение удалось и false, если курсор находится перед первой строкой.

- first() и last() — перемещают курсор соответственно на первую и последнюю строку набора данных. В случае,
## Q
9. Рассказать про паттерн DAO.
## A
Паттерн DAO(Data Access Object) заключается в том, что логика взаимодействия с БД
выносится из самой model в отдельный класс. Паттерн проектирования, когда отдельный класс
занимается взаимодействием с БД для конкретной сущности, называется DAO.
Используется для абстрагирования и инкапсулирования доступа к источнику данных,
управляет соединением с источником данных для получения и записи данных,
реализует необходимый для работы с источником данных механизм доступа.
выполняет функцию адаптера между компонентом и источником данных.
## Q
10. Что такое JPA?
## A
Воплощение концепции ORM.
JPA (Java Persistence API) это спецификация описывающая систему управления сохранением
java объектов в таблицы реляционных баз данных в удобном виде. ==
Сам JPA не умеет ни сохранять, ни управлять объектами, JPA только ==определяет правила
игры: как должен действовать каждый провайдер (Hibernate, EclipseLink, OJB, Torque и т.д.),
реализующий стандарт JPA. Для этого JPA определяет интерфейсы, которые должны быть
реализованы провайдерами. Также JPA определяет правила, как должны описываться
метаданные отображения и как должны работать провайдеры. Каждый провайдер обязан
реализовывать всё из JPA, определяя стандартное получение, сохранение и управление
объектами. Помимо этого, провайдеры могут добавлять свои личные классы и интерфейсы,
расширяя функционал JPA.
## Q
11. Что такое ORM?
## A
Если упростить, то ORM это связь Java объектов и записей в БД:

ORM — это по сути концепция о том, что Java объект можно представить как данные в БД (и
наоборот).
Она нашла воплощение в виде спецификации JPA — Java Persistence API.
Спецификация — это уже описание Java API, которое выражает эту концепцию. Спецификация рассказывает, какими средствами мы должны быть обеспечены (т.е. через какие интерфейсы мы сможем работать), чтобы работать по концепции ORM. И как использовать эти средства.
Так какие же преимущества нам даёт ORM в сравнение с JDBC?
- Позволяет бизнес-методам обращаться не к БД, а Java-классам
- Отделяет SQL-запросы от объектно-ориентированной модели
- Позволяет не думать о реализации БД
- Сущности основаны на бизнес-задачах, а не на структуре БД
- Управление транзакциями
ORM состоит из:
- API, который реализует базовые операции (СОЗДАНИЕ, ЧТЕНИЕ, ИЗМЕНЕНИЕ,
УДАЛЕНИЕ) объектов-моделей.
- Средства настройки метаданных связывания
- Техники взаимодействия с транзакциями, которая позволяет реализовать такие функции, как dirty checking, lazy association fetching и т.д.
А самыми распространёнными ORM фреймворком являются:
- Hibernate
- Java Object-Oriented Querying (jOOQ)
- MyBatis
- EclipseLink
- TopLink
есть 5 проблем, которые связаны с разницей между объектно-ориентированной
моделью и реляционной моделью:
1. Наследование
В реляционной модели нет никакого понятия, похожего на наследование, которое является
одним из ключевых принципов ООП.
2. Идентификация
Для БД есть только одна сущность, по которому объект может быть идентифицирован –
это Первичный Ключ (Primary Key). В то время как в Java есть такие вещи, как (entity1
== entity2) и (object1.equals(object2)) .
3. Ассоциации
В Java используются ссылки на объекты для ассоциации, а в реляционной модели –
Внешний Ключ (Foreign Key).
4. Доступ
В Java и в реляционной БД абсолютно разные способы получения доступа к объекту.
5. Инкапсуляция
Крайне часто, при разработке приложений, придется столкнуться с тем, что объектно-
ориентированная модель имеет больше классов, чем таблиц в БД.
## Q
12. Что такое Hibernate?
## A
Hibernate - это ==провайдер==, реализующий спецификацию JPA. Hibernate полностью реализует
JPA плюс добавляет функционал в виде своих классов и интерфейсов, расширяя свои
возможности по работе с сущностями и БД. Hibernate - это ==набор классов==, которые реализуют JPA интерфейсы.
Фреймворк Java, предназначенная для решения задач объектно-реляционного отображения
(ORM), самая популярная реализация спецификации JPA. Позволяет сократить объёмы
низкоуровневого программирования при работе с реляционными базами данных; может
использоваться как в процессе проектирования системы классов и таблиц «с нуля», так и для
работы с уже существующей базой.
Задачи, решаемые Hibernate:
- решает задачу связи классов Java с таблицами базы данных
- обеспечивает связь типов данных Java с типами данных SQL
- предоставляет средства для автоматической генерации и обновления набора таблиц, построения запросов и обработки полученных данных и может значительно уменьшить время разработки, которое обычно тратится на ручное написание SQL- и JDBC-кода.
- автоматизирует генерацию SQL-запросов и освобождает разработчика от ручной обработки результирующего набора данных и преобразования объектов, максимально облегчая перенос (портирование) приложения на любые базы данных SQL.

В отличие от SQL запросов через тот же JDBC , необходимо ВСЕГДА работать через
транзакции, т.е. открываем транзакцию - выполняем операцию - закрываем транзакцию.
.Делается это для того, чтобы изменения отслеживались Hibernate, находясь в Persistence
Context'e.

Какие проблемы могут быть при параллельной работе транзакции ?

- Проблема грязного чтения (Dirty Read): Эта проблема возникает, когда одна транзакция читает данные, которые были изменены другой транзакцией, но еще не подтверждены. Если первая транзакция откатывается, то данные, которые она прочитала, окажутся некорректными.

-  Проблема неповторяющегося чтения (Non-Repeatable Read): возникает при повторном чтении ячейки таблицы, в которую были между этими чтениями внесены изменения. Таким образом, при повторном чтении мы можем увидеть вовсе не те данные, что были там раньше.

- Проблема фантомного чтения (Phantom Read): возникает в том случае, когда одна и та же транзакция пытается повторно считать данные из какой-то таблицы, но между двумя этими считываниями какая-то другая транзакция занесла изменения в эту таблицу. В таком случае при повторном чтении мы увидим новые данные, которых не было ранее. феномен чтения фантомов, когда мы видим добавленные записи (INSERT).

- Проблема косой записи(Lost Update): Эта проблема возникает, когда две транзакции одновременно изменяют одну и ту же запись в базе данных. Если одна из транзакций сохраняется после другой, то изменения первой транзакции будут потеряны.

Базы данных реализуют различные уровни изоляции транзакций, чтобы устранить или снизить вероятность возникновения этих проблем. SQL стандарт определяет четыре уровня изоляции:

  

1. **READ UNCOMMITTED**: самый низкий уровень, который позволяет "грязное чтение".
2. **READ COMMITTED**: предотвращает "грязное чтение", но допускает "неповторяемое чтение".
3. **REPEATABLE READ**: исключает "грязное чтение" и "неповторяемое чтение", но может допускать "фантомное чтение".
4. **SERIALIZABLE**: самый высокий уровень, предотвращает "грязное чтение", "неповторяемое чтение", и "фантомное чтение", гарантируя полную изолированность и последовательное выполнение транзакций, как если бы они выполнялись одна за другой, а не параллельно.

Вот несколько подходов к управлению и решению этих проблем:

  

1. **Выбор Уровня Изоляции Транзакции**: Ключевым способом решения проблем параллельности является выбор подходящего уровня изоляции транзакции в зависимости от требований вашего приложения к точности данных и параллельности.
    
2. **Оптимистичное Согласование**: Предполагает, что конфликты возникают редко и не препятствует параллельным транзакциям до фазы фиксации. В конце транзакции происходит проверка, не были ли изменения нарушены другими транзакциями.
    
3. **Пессимистичное Согласование**: Противоположность оптимистичного согласования, предполагает блокировку данных на время работы с ними, чтобы предотвратить конфликты. Данные блокируются так, что другие транзакции не могут с ними взаимодействовать до тех пор, пока блокировка не будет снята.
    
4. **Изменения Запросов**: Изменение запросов к базе данных так, чтобы они избегали условий, которые провоцируют конфликты, например, выборка и блокировка только необходимых строк данных.
    
5. **Временные Метки**: Использование временных меток для контроля за порядком транзакций, чтобы определить, какие транзакции могут быть успешно завершены, а какие могут конфликтовать и потребуют прерывания.
    
6. **Алгоритмы Выделения Ресурсов**: Использование определенных алгоритмов для определения порядка, в котором транзакции получают доступ к ресурсам, для предотвращения взаимных блокировок.
    
7. **Использование Журналирования**: Ведение журнала изменений и последующее его использование для отката транзакций, если обнаруживается конфликт.
    
8. **Разделение Операций Чтения и Записи**: Иногда можно разделить операции чтения и записи таким образом, что они не мешают друг другу.
    
9. **Оптимизация Кода и Дизайна БД**: Улучшение проектирования базы данных и оптимизация кода запросов может сократить необходимость в длительных блокировках, тем самым уменьшая шансы возникновения конкурентных условий.
## Q
13. В чем разница между JPA и Hibernate? Как связаны все эти понятия?
## A

Hibernate(2001 г. выхода) по сути является прародителем JPA(первая версия выпущена 11 мая
2006 г.)
Реализации спецификации JPA называют также JPA Provider.
Hibernate одна из самых популярных открытых реализаций последней версии спецификации
(JPA 2.1). Даже скорее самая популярная, почти стандарт де-факто. То есть JPA только
описывает правила и API, а Hibernate реализует эти описания, впрочем у Hibernate (как и у
многих других реализаций JPA) есть дополнительные возможности, не описанные в JPA (и не переносимые на другие реализации JPA).
JPA это спецификация, а Hibernate - это ORM фреймворк/библиотека, которая совместима с
JPA. Как и в классическом ООП, класс, который реализует интерфейс, может иметь
дополнительные методы/свойства, так и Hiberante имеет больше фичей чем JPA.
Hibernate - это набор классов, которые реализуют JPA интерфейсы.
## Q
14. Какие классы/интерфейсы относятся к JPA/Hibernate?
## A
Что от чего наследуется:
Query -> TypedQuery -> Query -> SQLQuery
EntityTransaction -> Transaction
EntityManager -> HibernateEntityManager -> Session
EntityManagerFactory -> HibernateEntityManagerFactory -> SessionFactory
EntityManagerFactory — это встроенный интерфейс JPA. EntityManagerFactory может быть
использован для создания экземпляров EntityManager. Если вы хотите подключиться к другой
базе данных, необходимо создать другой экземпляр EntityManagerFactory.
EntityManager также является встроенным интерфейсом JPA. Он может быть создан с помощью экземпляра EntityManagerFactory. EntityManager описывает API для всех основных операций над Entity, а также для получения данных и других сущностей JPA. По сути - главный API для работы с JPA.
EntityManager представляет собой соединение базы данных. Вы можете использовать его для
выполнения операций с базой данных, таких как вставка/обновление/удаление или запрос
таблицы.

EntityTransaction также является встроенным интерфейсом JPA. Он может быть создан с
помощью EntityManager.
Сделка EntityTransaction инкапсулирует транзакцию базы данных.

2.1.1. Transaction
Этот объект представляет собой рабочую единицу работы с БД. В Hibernate транзакции
обрабатываются менеджером транзакций.
Транзакция — упорядоченное множество операций, переводящих базу данных из одного
согласованного состояния в другое. Согласованное состояние — это состояние, которое
подходит под бизнес-логику системы. То есть у нас не остается отрицательный баланс после
перевода денег, номер счета не «зависает в воздухе», не привязанный к человеку, и тому
подобное.

2.1.2. SessionFactory
Самый важный и самый тяжёлый объект (обычно создаётся в единственном экземпляре, при
запуске приложения). Необходима как минимум одна SessionFactory для каждой БД, каждый из которых конфигурируется отдельным конфигурационным файлом.

2.1.3. Session
Сессия используется для получения физического соединения с БД. Обычно, сессия создаётся
при необходимости, а после этого закрывается. Это связано с тем, что эти объекты крайне
легковесны. Чтобы понять, что это такое, можно сказать, что создание, чтение, изменение и
удаление объектов происходит через объект Session .
Точно так же ,как и Connection представляет сессию соединения с БД посредством драйвера,
так и Session (сессия) используется для получения физического соединения с базой данных (далее – БД). Благодаря тому, что сессия является легковесны объектом, его создают (т.е. открывают сессию) каждый раз, когда возникает необходимость, а потом, когда необходимо, уничтожают (т.е. закрывают сессию). Мы создаём, читаем, редактируем и удаляем объекты с помощью сессий.
Мы стараемся создавать сессии при необходимости, а затем уничтожать их из-за того, что ни не являются потоко-безопасными и не должны быть открыты в течение длительного времени.

2.1.4. Query
Этот объект использует HQL или SQL для чтения/записи данных из/в БД. Экземпляр запроса
используется для связывания параметров запроса, ограничения количества результатов,
которые будут возвращены и для выполнения запроса.

2.1.5. Configuration
Этот объект используется для создания объекта SessionFactory и конфигурирует
сам Hibernate с помощью конфигурационного XML-файла, который объясняет, как
обрабатывать объект Session .

2.1.6. Criteria
Используется для создания и выполнения объектно-ориентированных запросов для получения объектов.
## Q
15. Основные аннотации Hibernate, рассказать.
## A
@Entity
Эта аннотация указывает Hibernate, что данный класс является сущностью (entity bean). Такой
класс должен иметь конструктор по-умолчанию (пустой конструктор).
	Зачем пустой конструктор у Entity?
	Пустой конструктор в сущности (entity) используется в ORM (Object-Relational Mapping) для создания объектов сущностей при извлечении данных из базы данных. Вот несколько причин, почему пустой конструктор может быть необходим:
	
- Рефлексия и инстанцирование: ORM-фреймворки, такие как Hibernate, используют рефлексию для создания объектов сущностей. Пустой конструктор позволяет создать новый экземпляр сущности без передачи аргументов, что упрощает процесс инстанцирования.

- Пустой конструктор в сущности (entity) играет важную роль в этом процессе. Он позволяет ORM-фреймворку создать новый экземпляр сущности без передачи аргументов. Это упрощает процесс инстанцирования объекта, так как ORM-фреймворк может использовать рефлексию для вызова пустого конструктора и создания нового объекта сущности.

- Без наличия пустого конструктора, ORM-фреймворк может столкнуться с проблемами при создании объекта сущности, особенно если требуются аргументы для установки значений полей. Пустой конструктор обеспечивает базовую точку для создания объекта сущности, а дальнейшие значения полей могут быть установлены с помощью сеттеров или через рефлексию.

- Десериализация: При работе с сериализацией и десериализацией объектов, пустой конструктор может быть необходим для создания объекта сущности при восстановлении его из потока данных.

Сущность является простым классом POJO.
- Наличие публично доступного конструктора без аргументов
- Класс, его методы и сохраняемые поля не должны быть final, если они участвуют в маппинге. Hibernate использует механизмы проксирования для оптимизации запросов к базе данных и отложенной загрузки (lazy loading), а объявление метода как `final` мешает этому, потому что такой метод нельзя переопределить в прокси-классе.
- Если объект Entity класса будет передаваться по значению как отдельный объект (detached object), например через удаленный интерфейс (through a remote interface), он так же должен реализовывать Serializable интерфейс.
- Сохраняемые поля должны быть доступны только с использованием методов класса

@Table
С помощью этой аннотации мы говорим Hibernate, с какой именно таблицей необходимо
связать (map) данный класс. Аннотация @Table имеет различные аттрибуты, с помощью
которых мы можем указать имя таблицы, каталог, БД и уникальность столбцов в таблец БД.

@Id
С помощью аннотации @Id мы указываем первичный ключ (Primary Key) данного класса.

@GeneratedValue
Эта аннотация используется вместе с аннотацией @Id и определяет такие параметры, как strategy и generator Значение генерируется в базе и добавляется в поле нашего объекта.
GenerationType.IDENTITY) полагается на автоматическое увеличение значения столбца по
правилам, прописанным в БД-х. Для MySQL является наиболее правильной и распространенной стратегией, которую и стоит указывать, поскольку в зависимости от версии Hibernate стратегия AUTO меняется.

@Column
Аннотация @Column определяет к какому столбцу в таблице БД относится конкретное поле
класса (аттрибут класса).
Имеет различные атрибуты:
String name - задает имя колонки таблицы для поля класса
boolean unique - все значения должны быть уникальны
boolean nullable - поле может принимать значение null
int length - максимальная длина(для строк)

@ManyToMany, @ManyToOne, @OneToMany
Диаграммы отношений сущностей, которая показывает связь "многие ко многим" между двумя сущностями
## Q
16. Чем HQL отличается от SQL?
## A
HQL (Hibernate Query Language) - это объекто-ориентированный язык запросов, который очень похож на SQL. Главное различие языков HQL и SQL связано с тем, что SQL формирует запросы из наименований таблиц в базе данных и их столбцов, а HQL работает с сущностями
(классами) и их полями (аттрибутами класса).
HQL поддерживает такие понятия, как полиморфизм, наследование, ассоциация.
## Q
17. Что такое Query? Как передать в объект Query
параметры?
## A
https://javarush.com/quests/lectures/questhibernate.level10.lecture01
Query – это вспомогательный интерфейс , использующийся для написания запросов к
сущностям. и у него есть несколько реализаций на разные случаи. Объектно-ориентированное представление запроса в Hibernate. Запрос экземпляра получается
вызовом Session.createQuery ().
Query - часть спецификации Java Persistence API (JPA).
Hibernate может использовать оператор WHERE с именованными параметрами (Named
Parameters), определяя значение в режиме run-time. Для подстановки соответствующего
значения в запрос используется метод setParameter объекта Query, которому в качестве
параметров необходимо передать значения :
String hql = "FROM User where name = :paramName";
Query query = session.createQuery(hql);
query.setParameter("paramName", "Alex");
List 《User》 users = query.list();

## Q
18. Какие можно устанавливать параметры в hbm2ddl, рассказать про каждый из них.
## A
Итак, список возможных вариантов:
==validate== : проверяет схему, не вносит изменений в базу данных, может проверить, совместимы ли сопоставления объектов JPA с базовой схемой базы данных.;
==update== : обновляет схему, если схема отсутствует в БД, тогда схема создается;

==create== : создает схему, уничтожая предыдущие данные;
==create-drop== : удалить схему, когда SessionFactory закрывается явно, обычно, когда
приложение остановлено. схема не удаляется при закрытии сеанса. Он сбрасывается
только при закрытии SessionFactory.



19. Требования JPA к Entity-классам? Не менее пяти.
1. Entity класс должен быть отмечен аннотацией Entity или описан в XML файле конфигурации
JPA,
2. Entity класс должен содержать public или protected конструктор без аргументов (он также
может иметь конструкторы с аргументами)

Основные причины, по которым конструктор без аргументов необходим для Entity:

- **Создание экземпляров посредством рефлексии:** Библиотеки ORM, такие как Hibernate, используют механизм рефлексии для создания экземпляров классов сущностей при восстановлении объектов из данных, хранящихся в базе данных. Для этого часто требуется конструктор по умолчанию, чтобы ORM мог без проблем создать экземпляр класса.
    
- **Прокси и ленивая инициализация:** Некоторые фреймворки ORM используют ленивую загрузку (`lazy loading`), где конкретные атрибуты сущности загружаются из базы данных только по мере необходимости. Для реализации этого поведения иногда создаются прокси-классы, которые наследуются от класса сущности. Конструктор по умолчанию необходим, чтобы фреймворк мог корректно создать прокси.
    
- **Обязательное требование некоторых спецификаций:** JPA, в частности, требует, чтобы у ваших сущностей был публичный или защищённый (protected) конструктор по умолчанию. Это требование делает ваши классы сущностей POJO (Plain Old Java Object) совместимыми с спецификацией.
    
-  **Сериализация и десериализация:** В языках, таких как Java, конструктор без аргументов необходим для процессов сериализации и десериализации объектов, поскольку Java использует конструктор по умолчанию при десериализации объектов из потока данных.

3. Entity класс должен быть классом верхнего уровня (top-level class),
4. Entity класс не может быть enum или интерфейсом,
5. Entity класс не может быть финальным классом (final class),
6. Entity класс не может содержать финальные поля или методы, если они участвуют в
маппинге (persistent final methods or persistent final instance variables),
7. Если объект Entity класса будет передаваться по значению как отдельный объект (detached object), например через удаленный интерфейс (through a remote interface), он так же должен реализовывать Serializable интерфейс,
8. Поля Entity класс должны быть напрямую доступны только методам самого Entity класса и
не должны быть напрямую доступны другим классам, использующим этот Entity. Такие
классы должны обращаться только к методам (getter/setter методам или другим методам
бизнес-логики в Entity классе),
9. Enity класс должен содержать первичный ключ, то есть атрибут или группу атрибутов которые уникально определяют запись этого Enity класса в базе данных,

## Q

20 Жизненный цикл Entity в Hibernate? Рассказать.

1) new — объект создан, но при этом ещё не имеет сгенерированных первичных ключей и пока ещё не сохранен в базе данных;

2) managed — объект создан, управляется JPA, имеет сгенерированные первичные ключи;
3)  detached — объект был создан, но не управляется (или больше не управляется) JPA;

4) removed — объект создан, управляется JPA, но будет удален после commit'a транзакции.
## A
Persistence context - специальный контейнер, где объекты отслеживаются Hibernate. Объект в
данном статусе — так называемая хранимая сущность, которая присоединена к конкретной
сессии. Только в этом статусе объект взаимодействует с базой данных. При работе с объектом данного типа в рамках транзакции все изменения объекта записываются в базу.

Персистентный контекст - это набор экземпляров сущностей, загруженных из БД или только что созданных. Персистентный контекст является своего рода кэшем данных в рамках транзакции - это и есть кэш первого уровня. Внутри контекста персистентности происходит управление экземплярами сущностей и их жизненным циклом.

Java-объекты сущности проходят через несколько состояний, когда их использует Hibernate:
Transient(New) - состояние сущности, когда объект по сути только создан и еще не добвлен
в базу/получен из нее(не имеет первичного сгенерированного ключа). Находится вне поля
зрения Hibernate.

Persistent(managed) - когда объект добавлен и транзакция закоммичена -> добавляется
запись в БД и сущность отслеживается Hibernate. Это происходит, когда мы сохраняем
объект в БД или достаем его из БД и помещаем в сущность. Объект отслеживается
Hibernate до тех пор,пока не завершается сессия или пока вручную объект не
выкидывается из Persistence context. При изменении состояния объекта в Persistance state
Hibernate отслеживает изменение и генерирует SQL-код для изменения состояния
соответствующей записи в БД. ==Все изменения отслеживаются в пределах транзакции!
Только так Hibernate применит изменения к БД. ==
Detached - состояние объекта, когда вызван метод .detached() или закрыта сессия, т.е.
объект находится вне Persistance Context'a. Изменения не отслеживаются Hibernate, можно
присоединить обратно с помощью .merge()
Removed - объект помечен для удаления и следующий .commit() удаляет соответствующую

Вопросы для проверки знаний студентов по первому модулю предпроекта Ката: Что такое Git и для чего он нужен? Чем отличается Git и например GitHub? Что такое Commit в Git? Чем pull отличается от push? Что такое ветки в git и как создать, перейти на определенную ветку? Что такое Maven для чего нужен? Что такое POM файл и какую информацию он может содержать? Что такое зависимости? Можно ли без использования Maven добавить зависимости в свой проект, как это сделать? Основные фазы проекта под управлением Maven? Что такое реляционные базы данных?

20. Свойства транзакции ACID
**Atomicy** (атомарность или непрерывность) либо транзакции выполняются целиком, либо никак

**Consistency** (согласованность) данные в таблице должны соответствовать правилам и ограничениям

**Isolation** (изолированность) транзакции не должны пересекаться и влиять друг на друга

**Durability** (надёжность) если получили подтверждение, что транзакция выполнена, значит, данные в сохранности, даже если после этого произошёл сбой

5 Как достать все записи из таблицы используя HQL?


22. DDL DML
DDL — это язык определения данных : он используется для определения структур данных .
Например, в SQL это будут такие инструкции, как create table , alter table , ...
DML — это язык манипулирования данными : он используется для
манипулирования самими данными.

23. Обязательны ли аннотации @Column и @Table?
В случае отсутствия аннотации @Column, будет произведено неявное именование столбца таблицы по

атрибуту сущности. В случае отсутствия @Table будет неявное именование таблицы по имени класса-сущности.

24. ДОПЫ
Git - это распределенная система контроля версий, которая используется для отслеживания изменений в исходном коде проекта. Он позволяет разработчикам работать над проектом одновременно, отслеживать изменения, вносить правки и объединять их вместе.

В чем разница между Git и GitHub?

Git и GitHub - это два разных понятия. Git - это сама система управления версиями, в то время как GitHub - это веб-платформа для хостинга репозиториев Git. GitHub предоставляет дополнительные функции, такие как возможность совместной работы, отслеживание ошибок, запросы на объединение и другие инструменты для разработки программного обеспечения.

Git – система контроля версий (файлов).
git init – инициализация проекта (git создаёт свою папку .git и готов к работе)
git status - узнать статус нужного репозитория и файла;
git add – подготовка указанных файлов к коммиту, добавление их в index
git commit – закоммитить изменения (указав сообщение)
git branch – создание новой ветки
git checkout – перемещение указателя HEAD
git pull - используется для объединения изменений, присутствующих в удаленном репозитории, в локальный рабочий каталог;
git push - позволяет поместить изменения в главную ветку удаленного хранилища связанного с рабочим каталогом;
git reset - используется для сброса индекса и рабочего каталога до последнего состояния коммита;
git rm - удаление файлов из индекса и рабочего каталога.

Sequence - можно изначально сделать выборку, не нужно обращаться к бд
Identity - обращается к бд,