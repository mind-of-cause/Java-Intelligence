 **[Конспекты для подготовки к ревью core, pp](https://drive.google.com/drive/folders/1rPKSGI7m1NoFO4BxszBW6adMb28PaXuS?usp=sharing).

Конспекты правим в режиме онлайн, для этого открыли вам комментарии.

  

dis: [Kata inside](https://discord.com/invite/fEGCkHTe)

## [APPLICATION CONTEXT & DEPENDENCY INJECTION](https://habr.com/ru/articles/470305/)
## Q
1.  Что такое бин?
    
## A
JavaBeans — классы в языке Java, написанные по определённым правилам. Они используются для объединения нескольких объектов в один (англ. bean — фасоль, кофейное зерно) для удобной передачи данных.

Spring-бины − это классы, созданием экземпляров которых и установкой в них зависимостей управляет контейнер фреймворка Spring.

Основные черты JavaBeans включают в себя следующее:
- Публичные свойства: Классы JavaBeans предоставляют публичные методы доступа (геттеры и сеттеры) для свойств, что обеспечивает инкапсуляцию данных.
- Поддержка сериализации: JavaBeans могут быть сериализованы, что позволяет сохранять и восстанавливать их состояние.


Spring-бины − это классы, созданием экземпляров которых и установкой в них зависимостей управляет контейнер фреймворка Spring. Бины предназначены для реализации бизнес-логики приложения.

Несколько ключевых аспектов Spring-бинов:
application context создаётся вначале контейнера
Бин Фэктори создаётся по требованию

- Управление жизненным циклом: Контейнер Spring управляет жизненным циклом бинов, создавая их, удовлетворяя зависимости, и уничтожая, когда они больше не нужны. Это упрощает управление ресурсами и обеспечивает инверсию управления.

- Инъекция зависимостей: Spring осуществляет внедрение зависимостей в бины, что позволяет избежать жесткой связи между компонентами приложения. Зависимости могут быть внедрены через конструктор, сеттеры или поля.

- Конфигурация: Бины могут быть настроены с использованием различных методов конфигурации, таких как XML-конфигурация, аннотации или JavaConfig. Это предоставляет гибкость в выборе метода конфигурации в зависимости от потребностей проекта.

- [Аспекты безопасности и транзакций](https://habr.com/ru/articles/428548/): Spring предоставляет возможности аспектно-ориентированного программирования (AOP), которые позволяют внедрять аспекты, такие как безопасность или транзакции, в бины без изменения их кода.

- Аннотации: С применением аннотаций в Spring можно значительно упростить конфигурацию. Например, аннотация @Component используется для пометки класса как бина.
    
## Q
- Виды бинов?
    
## A
Лет 10 назад массовое распространение получила концепция EJB – Enterprise Java Beans.

Entity Bean – бин, цель которого — хранить некоторые данные. В логику такого бина встроен механизм сохранения себя и своих полей в базу данных. Такой объект может быть уничтожен, а потом воссоздан из базы заново. Но кроме хранения данных у него нет никакой логики.

Session Bean – это функциональный бин. У каждого Session Bean есть своя функция. Один делает одно, другой другое. Такие бины работают с другими объектам и бинами, а не со своими данными.

Session Beans делятся на две категории.

Stateless Session Bean – это бин, который не хранит во внутренних переменных важных данных, нужных для его работы. Такой бин можно уничтожить, а затем заново создать, и он будет выполнять свою функцию, как и раньше.

Statefull Session Bean – это бин, который хранит у себя внутри данные, которые использует при работе. Если мы вызываем методы этого бина, то в каждом следующем вызове он может использовать часть данных, переданных ему в предыдущих. И все равно этот бин – это не то же самое, что обычный объект

**

### Q
Области видимости бинов? Entity и session бины?
    

Область видимости — scope, скоуп.

Существует 2 области видимости по умолчанию.

Активированный по умолчанию:

Singleton

Область видимости по умолчанию. В контейнере находится всего 1 экземпляр бина, при каждом вызове в процессе жизненного цикла операция взаимодействует с уже изменённым бином предыдущей операцией.
**Beans that are singleton-scoped and set to be pre-instantiated (the default) are created when the container is created. Otherwise, the bean is created only when it is requested. Creation of a bean potentially causes a graph of beans to be created, as the bean’s dependencies and its dependencies' dependencies (and so on) are created and assigned. Note that resolution mismatches among those dependencies may show up late, i.e. on first creation of the affected bean.****
**
Prototype

В контейнере может находится любое количество экземпляров бина,  примеры использования:
-  Сохранение уникального состояния на протяжении последовательности операций
-  Разнородные вычисления с неизвестным числом компонентов. Если приложение запускает различные вычисления или задачи и каждая задача требует собственного экземпляра компонента для хранения промежуточного состояния вычисления.
- Использование вместе с Stateless Beans. Bcontext-зависимые операции можно изолировать в `prototype` бины и инжектить их в stateless beans. Таким образом, вы сможете избежать необходимости управления состоянием в системе, при этом используя stateless beans для общей логики
- каждый раз новый

Не активированный по умолчанию:

Custom thread scope - похож на Web, нужно включать. Spring по умолчанию не предоставляет thread scope, но его можно активировать. Каждый запрос на бин в рамках одного потока будет возвращать один и тот же бин. 
Пользовательская область видимости потока может быть полезна в многопоточных приложениях и для задач вне контекста веб-приложения, где требуется, чтобы каждый поток имел собственные инстансы бинов.
- необходимо зарегистрировать собственную реализацию `Scope`
- Регистрация области видимости в контексте
- Использование области видимости потока с @Scope("thread")

И 4 области видимости в веб-приложении.

Request

Область видимости — 1 HTTP запрос. На каждый запрос создается новый бин

Session

Область видимости — 1 сессия. На каждую сессию создается новый бин

Application

Область видимости — жизненный цикл ServletContext. Бин существует в течение всего времени жизни веб-приложения.

WebSocket

Область видимости — жизненный цикл WebSocket. Бин существует в течение жизненного цикла WebSocket соединения.

~~**Global Session**~~

~~Эта область видимости используется в портлетных приложениях и создает бин на уровень глобальной портлетной сессии.~~


Область видимости указывается с помощью аннотации @Scope на @Bean методах.



## Q
5. Чем бин отличается от POJO-класса?
    
## A
POJO (англ. Plain Old Java Object) — «простой Java-объект в старом стиле», простой Java-объект, не унаследованный от какого-то специфического объекта и не реализующий никаких служебных интерфейсов сверх тех, которые нужны для бизнес-модели.

Spring Bean — это, по сути, объект, управляемый Spring. В частности, это объект, который создается, настраивается и иным образом управляется контейнером Spring Framework . Spring Bean определяются в файлах конфигурации Spring (или, в последнее время, с помощью аннотаций), создаются контейнерами Spring, а затем внедряются в приложения.


1. Все JavaBeans являются POJO, но не все POJO являются JavaBeans:
    

- Все JavaBeans считаются POJO (Plain Old Java Objects), но не каждый POJO соответствует стандарту JavaBean. JavaBean - это подмножество POJO, которое следует определенным соглашениям, таким как наличие геттеров и сеттеров, конструктора без аргументов и т.д.
    

3. Serializable:
    

- Предполагается, что JavaBeans поддерживают сериализацию и должны реализовывать интерфейс Serializable. Однако, и, не все POJO обязаны быть Serializable.
    

5. Приватные поля:
    

- JavaBeans требуют, чтобы поля были приватными, что обеспечивает контроль доступа к данным.
    

7. Геттеры и/или сеттеры:
    

- JavaBeans должны предоставлять геттеры и/или сеттеры для доступа к их полям. Это обеспечивает инкапсуляцию данных и контролируемый доступ.
    

9. Конструктор без аргументов:
    

- JavaBeans должны иметь конструктор без аргументов.Этот конструктор используется при создании экземпляра класса средствами рефлексии.
    

11. Обращение к полям:
    

- К полям JavaBean следует обращаться через геттеры и сеттеры или конструкторы. 
    

  
## Q
6. Что такое Inversion of Control и как Spring реализует этот принцип?
    

## A

Inversion of Control (IoC), или принцип инверсии управления, представляет собой принцип проектирования программного обеспечения, при котором контроль над выполнением программы переносится из самой программы во внешний фреймворк или контейнер.

Ключевая особенность приложения, написанного на Spring, состоит в том что большую часть объектов создаем не мы, а Spring. Мы лишь конфигурируем классы (с помощью аннотаций, либо в конфигурационном XML), чтобы «объяснить» фреймворку Spring, какие именно объекты он должен создать за нас, и полями каких объектов их сделать. Spring управляет созданием объектов и потому его контейнер называется IoC-контейнер. IoC расшифровывается как Inversion of Control. А объекты, которые создаются контейнером и находятся под его управлением, называются бинами.

На вход контейнер Spring принимает наши обычные классы (которые впоследствии будут бинами).

На выходе Spring производит объекты – бины. То есть экземпляры классов, созданные в соответствии с конфигурацией и внедренные куда нужно (в другие бины). После этого никакие операторы new нам не понадобятся, мы будем работать в классе-бине с его полями-бинами так, будто они уже инициированы. Конечно, не со всеми полями, а только с теми, которые сконфигурированы как бины. Остальные инициализируются как обычно, в том числе с помощью оператора new.

## Q 

BeanFactory vs ApplicationContext - кто такие, какие отличия?

## A

**BeanFactory** и **ApplicationContext** в Spring - это интерфейсы, которые используются для настройки и управления различными компонентами (бинами) приложения. Они управляют жизненным циклом бинов и обеспечивают доступ к бинам по идентификаторам и именам.

Вот основные отличия между ними:

  

1. **BeanFactory:** Это базовый интерфейс для любого контейнера Spring, который может управлять любым числом бинов. Он используется для настройки и управления жизненным циклом бинов. Он менее сложен и обеспечивает базовые функции вроде Lookup и Lifecycle.
    
2. **ApplicationContext:** Это наследник интерфейса BeanFactory и предлагает намного больше функциональности. Он включает все функции BeanFactory и добавляет более сложные элементы, такие как обработку событий, предоставление поддержки различных областей видимости и интеграцию с AOP. Он также упрощает международную поддержку (i18n) и внедрение ресурсов.
    

В общем, ApplicationContext - это расширенная версия BeanFactory с более сложной функциональностью. И хотя BeanFactory немного облегчает место, обычно рекомендуется использовать ApplicationContext для большинства приложений, поскольку он предоставляет больше возможностей и автоматически подключает большинство полезных сервисов Spring, таких как сообщения об ошибках и поддержка исключений.

## Q
6. Для чего существует такое количество конфигураций ApplicationContext?
    

## A

1. Чтоб можно было задавать разные способы конфигурирования

2. Для обратной совместимости
3.  **Различные среды разработки и развёртывания**: Некоторые контексты оптимизированы для использования в простых стендовых приложениях или инструментариих времени разработки, в то время как другие предназначены для полнофункциональных корпоративных приложений. Например, `AnnotationConfigApplicationContext` подходит для приложений с Java-конфигурацией, а `XmlWebApplicationContext` предназначен для веб-приложений на основе XML.

4. **Гибкость конфигурации**: Разные типы приложений требуют разных способов конфигурации. Например, для стандартных Java-приложений обычно достаточно `ClassPathXmlApplicationContext` или `FileSystemXmlApplicationContext`, которые позволяют загружать конфигурации бинов из XML-файлов. Однако, для более современных приложений, которые используют подход на основе аннотаций, может использоваться `AnnotationConfigApplicationContext`.

5. **Интеграция с другими технологиями**: Некоторые реализации `ApplicationContext` предоставляют интеграцию с другими технологиями и системами. `GenericWebApplicationContext`, например, предназначен для использования в web-приложениях с Spring MVC или Spring WebFlux.
    
4. **Особенности тестирования**: Для упрощения тестирования, Spring предоставляет `AnnotationConfigWebApplicationContext` и `GenericApplicationContext`, которые облегчают настройку и управление контекстом Spring в тестовых средах.
    
5. **Оптимизация производительности**: Отдельные реализации контекста нацелены на улучшение производительности для определённых типов приложений или операционных сред, позволяя при этом избегать ненужной функциональности и связанных с ней накладных расходов.
    
6. **Поддержка реактивного программирования**: `ReactiveWebApplicationContext` предназначен для использования с Spring WebFlux и поддерживает реактивное программирование с использованием парадигмы обработки событий и асинхронного реагирования на потоки данных.

  
Сразу определим, что ApplicationContext — это главный интерфейс в Spring-приложении, который предоставляет информацию о конфигурации приложения.

У Spring есть 4 способа конфигурации:

1. Xml конфигурация - ClassPathXmlApplicationContext(”context.xml”);
    
2. Groovy-конфигурация- GenericGroovyApplicationContext(”context.groovy”);
    
3. Конфигурация через аннотации с указанием пакета для сканирования - AnnotationConfigApplicationContext(”package.name”);
    
4. JavaConfig - конфигурация через аннотации с указанием класса (или массива классов) помеченного аннотацией @Configuration - AnnotationConfigApplicationContext(JavaConfig.class).
    

  
## Q
7. @Autowired, где можно ставить и какие есть отличия? Плюсы и минусы каждого способа. Почему не рекомендуется связывать через поле?
    
## A
  
Начиная с Spring 2.5, в фреймворке были введены управляемые аннотациями dependency injection . Основная аннотация этой функции – @Autowired.

В приложении может быть использовано 3 варианта внедрения зависимостей:

1. Через конструктор
    

Инъекция через конструкторы хороша для обязательных зависимостей — тех, которые требуются для корректной функциональности объекта. Передавая их через конструктор, можно быть уверенным в том, что объект полностью готов к использованию с момента создания. Поля, присвоенные в конструкторе, также могут быть final, что позволяет объекту быть полностью неизменным или как минимум защищает необходимые поля.

Но может возникнуть циклическая зависимость.

**Circular dependencies**

If you use predominantly constructor injection, it is possible to create an unresolvable circular dependency scenario.

For example: Class A requires an instance of class B through constructor injection, and class B requires an instance of class A through constructor injection. If you configure beans for classes A and B to be injected into each other, the Spring IoC container detects this circular reference at runtime, and throws a `BeanCurrentlyInCreationException`.

One possible solution is to edit the source code of some classes to be configured by setters rather than constructors. Alternatively, avoid constructor injection and use setter injection only. In other words, although it is not recommended, you can configure circular dependencies with setter injection.

Unlike the _typical_ case (with no circular dependencies), a circular dependency between bean A and bean B forces one of the beans to be injected into the other prior to being fully initialized itself (a classic chicken/egg scenario).

Происходит при создании экземпляра бина.  

2. Через сеттеры 
    

Внедрение через конструктор может приводить к циклическим зависимостям. Чтобы этого избежать, можно использовать ленивую инициализацию бинов или внедрение через сеттер.

Сеттеры следует использовать для инъекций опциональных зависимостей. Класс должен быть способен функционировать, даже если они не были предоставлены
  
Происходит после создания экземпляра бина, но перед его использованием.

3. Через аннотацию над полем
    

Не рекомендуется использовать, т.к. для этого применяется рефлексия, снижающая производительность.

При внедрении прямо в поле нет прямого способа создания экземпляра класса со всеми необходимыми зависимостями. Это связано с тем, что внедрение зависимостей в поле происходит после создания объекта, и контейнер Spring не может внедрить зависимости в конструктор, так как объект уже был создан.

Происходит непосредственно после создания экземпляра бина и перед вызовом любых методов жизненного цикла (например, инициализирующих методов).

  
При имении нескольких кандидатов на внедрение -> Используем аннотация @Qualifier(“id”)
@Primary

![](https://lh7-us.googleusercontent.com/rhmW4_ijvZlyg5CSjyVNt-TFuRnaeAOV5Sm0wmfSo-ZNuoZ5BgyG6Pr76Vi3idd_FASZRfApyb2EhB8YbFyhnu2hFcbH6RnfTI522MkSgld0x1UT6bBFIkF1IOOr5BLWH2WWUdUZVfe3UD4k3gJ_0N8)

  

## Q
9. Что такое Dependency Injection?
    
## A
  
Это концепция в объектно-ориентированном программировании, которая позволяет классу получать свои зависимости (такие как объекты сервисов или другие классы) извне, вместо того чтобы создавать их самому. Это способ обеспечения инверсии управления (IoC) в приложении.

## Q
 Какие бины будут использоваться для настройки приложения?
    
## A
Аннотация @Configuration, прописанная перед классом, означает, что класс может быть использован контейнером Spring IoC как конфигурационный класс для бинов.

Аннотация @Bean, прописанная перед методом, информирует Spring о том, что возвращаемый данным методом объект должен быть зарегистрирован, как бин.

Аннотация @ComponentScan("path") задает путь по которому спринг будет искать классы для создания бинов.

Бины для управления жизненным циклом:

Бины могут реализовывать интерфейс InitializingBean или использовать аннотации @PostConstruct и @PreDestroy для выполнения дополнительных действий при инициализации или уничтожении.

## Q
аннотация PostConstruct 

# A
Аннотация `@PostConstruct` в Java используется на методе, который должен быть выполнен после завершения фазы конструирования бина, то есть после того, как все инъекции зависимостей были выполнены. Это особенно полезно для выполнения любых инициализаций, которые требуют, чтобы все необходимые зависимости бина были полностью установлены.

Этот метод с аннотацией `@PostConstruct`:  

- Обычно используется для инициализации кода, который мы хотим запустить только один раз, непосредственно после создания экземпляра бина.
- Вызывается только один раз в жизненном цикле бина.
- В Java EE 5 и выше, а также в Spring Framework, поддерживается из коробки без дополнительных настроек.
- Метод с аннотацией `@PostConstruct` может быть объявлен с любым уровнем доступа (публичным, защищенным или с пакетным доступом), но должен возвращать `void` и не принимать никаких аргументов.

Пример использования `@PostConstruct`:

```java


import javax.annotation.PostConstruct;

@Component
public class MyBean {

    @PostConstruct
    public void init() {
        // инициализация, которая при необходимости выполняется после установки всех свойств бина
    }
    
    // ...
}
```

  

Этот метод `init()` будет автоматически вызван после того, как контейнер Spring создает экземпляр класса `MyBean` и устанавливает все его зависимости с помощью автопроводки (`autowiring`).

## Q
аннотация PathVariable

## A
Аннотация `@PathVariable` в Spring Framework используется для извлечения значений из URI пути и передачи этих значений в методы контроллера как параметры. Она часто применяется в RESTful веб-сервисах, где URL содержит параметры, идентифицирующие ресурс или ресурсы, к которым осуществляется доступ.

**Пример использования `@PathVariable`:**

Представим, что у нас есть веб-приложение, управляющее пользователями, и мы хотим получить информацию о конкретном пользователе по его ID. URL для этого может выглядеть следующим образом: `/users/{userId}`.

В Spring контроллере мы можем использовать `@PathVariable` для извлечения `userId` непосредственно из URL:
  
```java


@RestController
@RequestMapping("/users")
public class UserController {

    @GetMapping("/{userId}")
    public ResponseEntity<User> getUserById(@PathVariable("userId") Long id) {
        // Здесь должен быть метод сервиса для поиска пользователя по id
        User user = userService.findById(id);
        return ResponseEntity.ok(user);
    }
}
```

В этом примере:

- `@RestController` указывает, что данный класс является контроллером REST.
- `@RequestMapping("/users")` указывает, что все методы этого контроллера будут обрабатывать запросы с базовым путем `/users`.
- В методе `getUserById`, `@GetMapping("/{userId}")` указывает, что этот метод будет обрабатывать HTTP GET запросы, URL которых соответствует шаблону `/users/{userId}`.
- `@PathVariable("userId")` используется для извлечения значения, указанного в шаблоне `{userId}` из URL, и передачи его в параметр `id` метода `getUserById`.


Аннотация `@PathVariable` позволяет вашим методам быть более читаемыми и понятными, явно указывая, какие значения используются из URL для выполнения бизнес-логики.
## SPRING MVC

## Q
 Как получить данные из файла .properties?
    
## A
.properties — файловое расширение для файлов, которые используются в основном в технологиях Java для хранения конфигурационных параметров программы (логин, пароль, URL и пр.).

Каждый параметр сохраняется парой двух переменных строчного типа, одна сохраняет имя параметра (так называемый ключ), а другая сохраняет значение. Каждая строка файла .properties, как правило, хранит значения одного параметра.
  
В Spring Framework, для получения данных из файла `.properties`, вы можете использовать `@PropertySource` в сочетании с `Environment` или `@Value` аннотации.

Пример использования `@PropertySource` и `Environment`:

1. Создайте файл конфигурации `application.properties` в ресурсах:
```  properties

   application.properties

   app.name=MyApp

   app.version=1.0
   ```

2. Используйте аннотацию `@PropertySource` в конфигурационном классе:

  
```java 
  import org.springframework.context.annotation.Configuration;
  
   import org.springframework.context.annotation.PropertySource;

   @Configuration

   @PropertySource("classpath:application.properties")

   public class AppConfig {

       // Класс конфигурации
   }
   
```

  

3. Внедрите `Environment` и получите значения свойств:

   ```java

   import org.springframework.beans.factory.annotation.Autowired;

   import org.springframework.core.env.Environment;

   import org.springframework.stereotype.Component;

   @Component

   public class MyComponent {

       @Autowired

       private Environment environment;

       public void printProperties() {

           System.out.println("App Name: " + environment.getProperty("app.name"));

           System.out.println("App Version: " + environment.getProperty("app.version"));

       }

   }
```
  

Пример использования `@Value` аннотации:

1. Создайте файл конфигурации `application.properties` в ресурсах:

  properties

   # application.properties

   app.name=MyApp

   app.version=1.0

  

2. Используйте `@Value` аннотацию в классе компонента:

  ```java

   import org.springframework.beans.factory.annotation.Value;

   import org.springframework.stereotype.Component;

   @Component

   public class MyComponent {
       @Value("${app.name}")
       private String appName;
       @Value("${app.version}")
       private String appVersion;
       public void printProperties() {
           System.out.println("App Name: " + appName);
           System.out.println("App Version: " + appVersion);

       }

   }
```
  

В обоих примерах, значения свойств будут взяты из файла `application.properties` и могут быть использованы в вашем приложении. Вы можете выбрать подход, который лучше подходит вашим требованиям и структуре приложения.

## Q
11. Как запустить Спринг-приложение из-под сервера Tomcat?
    
## A
Общая логика действий:

1. В вашем файле pom.xml укажите, что вы хотите упаковать ваш проект как WAR-файл. (<packaging>war</packaging>)
    
2. Убедитесь, что в вашем файле pom.xml есть зависимость для встроенного сервера Tomcat.
    
3. В вашем проекте создайте класс, который будет расширять SpringBootServletInitializer. Этот класс должен быть аннотирован @SpringBootApplication.
    
4. Сделать .jar файлы доступными (перенести в папку webapp/WEB-INF/lib)
    
5. Скомпилировать и задеплоить War файл
    
6. Запустите сервер Tomcat (startup.bat)
    
7. Тестирование ([http://localhost:8888/books/list](http://localhost:8888/books/list))
    

  
## Q
12.  Что такое Artifacts?
    
## A
В контексте сборки и развертывания программного обеспечения, термин "артефакты" (artifacts) обозначает файлы, которые являются результатами процесса сборки проекта. Эти файлы представляют собой конечные продукты, которые могут быть использованы для различных целей, таких как развертывание, тестирование или поставка программного обеспечения.

В различных контекстах, например, в Maven, Gradle, или других системах сборки, "артефакт" обычно относится к файлу, такому как JAR, WAR, или другие архивы, которые создаются в процессе сборки проекта. Эти артефакты содержат скомпилированный код, ресурсы и другие необходимые файлы для работы программы.

  

Примеры артефактов в различных типах проектов:

Java проект (Maven/Gradle):

JAR-файл, WAR-файл, или другие архивы, содержащие байт-код Java, ресурсы, библиотеки и т.д.

Веб-приложение:

WAR-файл, содержащий веб-ресурсы, статические файлы, JSP-страницы, и другие компоненты веб-приложения.
  
## Q
13. В чем отличие артефакта war от war exploded?
    
## A
war артефакт — упакованный в архив проект, только уже скомпилированный, и в котором изменена структура папок так, чтобы его можно было выкладывать уже напрямую на Tomcat

  

war exploded - то же самое, только в незаархивированном виде

  
## Q
14.  Какая разница между аннотациями @Component, @Repository и @Service в Spring?
    
## A
Все они определяют бины Spring. Однако между ними всё же есть разница.

  

@Component — универсальный компонент, ее роль ограничивается указанием класса как кандидата для обнаружения и регистрации Spring IoC. Общий кейс и условно родитель для специализированных аннотаций вроде репозитория и сервиса

  

@Repository — компонент, который применяется к классам, которые работают с базой данных, выполняют операции сохранения, извлечения и обновления данных. @Repository предоставляет дополнительные функциональные возможности, такие как преобразование исключений в исключения типа DataAccessException.

  

@Service — фасад для некоторой бизнес логики

Пользовательские аннотации, производные от @Component, могут добавлять специальную логику в бинах.

Например, бины, получившиеся при помощи @Repository, дополнительно имеют обработку для JDBC Exception

@Service и @Repository - алиасы @Component

![](https://lh7-us.googleusercontent.com/wUaXLqsG83wDNcPvWN3fH2Z0F1haT2qbR-uBhlNFEFXcvBF2jQLQVnGWoGJ8_BWOhZFdLusVxvYa--x3ETG8nJvRp-0Jrr5U0MKqcuAvo3gieUVGs6GbN3UG7LQsM7XZCJII2sRBE9zVmMtDEwbakxE)![](https://lh7-us.googleusercontent.com/ABztB2p0c2V2IVhsgRZzSSBRgXMfxJNeppSt1IoTX-g_WUkxgZ0jXpqGpAkNmRRpfiP-cgHgyzsqjDHfBGYEaL1QVy7JVtrVlsyj1prJq7_P9n5oc9nNAmdOBWRt9F0KWeVNSRXPyZ_kkhOkYyg7Oqw)

  
## Q
15.  Как выглядит структура MVC-приложения?
    

## A

Model (Модель):

- Инкапсулирует(скрывает) данные приложения.
- Представляет бизнес-логику и методы работы с данными.
- Не зависит от контроллера и представления.
- Может содержать сущности, сервисы и репозитории.

Controller (Контроллер):

- Обрабатывает запросы от пользователя.

- Взаимодействует с моделью для получения и обновления данных.

- Вызывает нужные ресурсы и объекты для выполнения действий.

- Отправляет данные в представление для отображения.

- Может перенаправлять пользователя на другие страницы.


View (Представление):

- Отвечает за отображение данных приложения пользователю.

- Может быть HTML-страницей, JSP-файлом, шаблоном Thymeleaf и др.

- Получает данные от контроллера и отображает их пользователю.

- Не содержит бизнес-логики, только логика отображения.

  
Spring MVC и View-решения:

Spring MVC поддерживает различные поставщики View, такие как JSP, JSF, Thymeleaf и другие.

Эти технологии позволяют легко интегрировать представления в приложение.

  
## Q
16.  Чем контроллер отличается от сервлета?
    
## A
Вкратце:

Сервлеты - низкоуровневые компоненты, работающие с HTTP-протоколом, обрабатывают запросы и формируют ответы напрямую.

Контроллеры - высокоуровневые компоненты в архитектуре MVC, отвечают за обработку бизнес-логики и делегирование задач сервисам, работают в контексте веб-фреймворков.

Сервлеты более прямо связаны с HTTP, в то время как контроллеры предоставляют абстракцию для обработки запросов в рамках фреймворка.

Подробно:

Контроллер и сервлет — это два разных компонента в веб-разработке, но они часто используются вместе. Рассмотрим основные различия между контроллером и сервлетом:

Уровень абстракции:

Сервлет: Это низкоуровневый компонент веб-приложения, предоставляющий базовый механизм для обработки HTTP-запросов и генерации HTTP-ответов. Сервлеты написаны на языке Java и обычно содержат логику для обработки запросов и формирования ответов.

Контроллер: Это более высокоуровневый компонент, который обычно представляет собой часть фреймворка веб-приложения. Контроллер обеспечивает отделение бизнес-логики от обработки HTTP-запросов. Он предоставляет структуру для обработки запросов и вызова соответствующих методов для выполнения конкретных операций.

Примеры использования:

  
Сервлет: Используется для создания динамических веб-страниц, обработки форм, обработки загрузки файлов и других прямых задач, связанных с HTTP.

  
Контроллер: Используется для реализации бизнес-логики приложения, управления навигацией, обработки входящих запросов и формирования ответов.

Пример фреймворка:


Сервлет: Часто используется напрямую или встроен в различные фреймворки, такие как Java Servlet API.

Контроллер: Часто является частью веб-фреймворков, например, в Spring MVC, где его роль заключается в обработке запросов и управлении бизнес-логикой.

  

Итак, контроллер обычно является абстракцией бизнес-логики и может использоваться для более эффективного организации кода в рамках паттерна MVC, в то время как сервлет предоставляет более низкоуровневый подход, работая напрямую с HTTP-протоколом и обрабатывая запросы без четкого разделения бизнес-логики.

  
  
  
## Q
17.  Какая основная зависимость фреймворка Спринг? Почему во многих сборках она не указывается явно?
    
## A
Spring-core. Не указывается потому, что она включается по умолчанию.

  
## Q
18.  Как вернуть страницу в контроллере? Как вернуть данные?
    
## A
Вернуть страницу (View):


Используя строку с именем представления:

```java

Copy code

@Controller

public class MyController {

    @GetMapping("/examplePage")

    public String getPage() {

        return "example"; // Имя представления (HTML-файла) без расширения

    }

}
```

Используя объект ModelAndView:

```java

Copy code

@Controller

public class MyController {

    @GetMapping("/examplePage")

    public ModelAndView getPage() {

        ModelAndView modelAndView = new ModelAndView("example");

        // Дополнительные параметры, если необходимо

        return modelAndView;

    }

}
```
  

Вернуть данные (Model):

  

Используя объект Model:

```java

Copy code

@Controller

public class MyController {

    @GetMapping("/exampleData")

    public String getData(Model model) {

        model.addAttribute("varName", "yourData");

        return "dataPage"; // Имя представления (HTML-файла) для отображения данных

    }

}
```
  В этом примере `@Controller` аннотирует класс `MyController`, делая его компонентом Spring MVC, который может обрабатывать HTTP-запросы. Метод `getData` использует аннотацию `@GetMapping` для обработки GET-запросов на URL `/exampleData`. Объект `Model` используется для передачи данных в представление. В этом случае в модель добавляется атрибут с именем `varName` и значением `"yourData"`. Возвращаемое значение метода `"dataPage"` указывает на имя HTML-шаблона (обычно Thymeleaf, FreeMarker или JSP), который будет использован для генерации HTML-страницы. Этот шаблон должен располагаться в соответствующей директории проекта и будет заполнен данными из модели, чтобы сформировать итоговую страницу, отправляемую пользователю.

Используя объект ResponseEntity:

```java

Copy code

@Controller

public class MyController {

    @GetMapping("/exampleData")

    public ResponseEntity<String> getData() {

        return ResponseEntity.ok("yourData");

    }

}
```
Выбор зависит от того, возвращается ли HTML-страница или данные, и каким способом предпочтительнее в конкретной ситуации.

## Q
Model vs ModelAndView vs ModelAndMap

# A
В Spring MVC, `Model`, `ModelAndView`, и `ModelMap` используются для передачи данных из контроллеров в представления. Несмотря на схожую цель, они используются немного по-разному и имеют свои особенности. 
### Model 
`Model` является интерфейсом, который определяет хранилище для атрибутов модели. Он предоставляет методы для добавления атрибутов к модели. Атрибуты модели используются для передачи данных между контроллерами и представлениями. Основное предназначение `Model` - это предоставление данных, которые контроллер хочет передать в представление. Пример использования в контроллере: 
```java
@GetMapping("/example") public String getModelData(Model model) {
model.addAttribute("message", "Hello, World");
return "exampleView"; 
} 
```
### ModelAndView
`ModelAndView` является классом, который содержит как модель, так и имя представления. В отличие от `Model`, который просто предоставляет данные, `ModelAndView` также указывает, какое представление должно быть отрендерено с этими данными. Это удобно, когда имя представления и данные модели определяются динамически внутри метода контроллера. Пример использования в контроллере:
```java 
@GetMapping("/example") public ModelAndView getExample() { 
ModelAndView modelAndView = new ModelAndView("exampleView"); modelAndView.addObject("message", "Hello, World"); 
return modelAndView; 
} 
``` 
### ModelMap
`ModelMap` служит альтернативой `Model`, предоставляя реализацию `Map` для хранения атрибутов модели. Он в основном используется, когда нужно передать коллекцию значений в представление. `ModelMap` позволяет управлять атрибутами модели, используя ключи и значения, подобно работе с картой. `ModelMap` идеально подходит для случаев, когда нужно передать в представление сложную структуру данных. Пример использования в контроллере: 
```java 
@GetMapping("/example") public String getExampleData(ModelMap modelMap) {
modelMap.addAttribute("message", "Hello, World");
return "exampleView"; } 
```
### Заключение 
- Используйте `Model` или `ModelMap` для передачи данных в представление, когда вы знаете, какое представление будет использоваться. - Используйте `ModelAndView`, когда вам нужно динамически определить, какое представление будет отрендерено, и передать в него данные модели.

## Q

ModelAtribute vs RequestParam
## A
В Spring MVC аннотации `@ModelAttribute` и `@RequestParam` используются для извлечения данных из запроса, но они работают немного по-разному и предназначены для выполнения разных задач. 
### @ModelAttribute
Аннотация `@ModelAttribute` используется для автоматического связывания входящих HTTP параметров с объектом модели (доменным объектом) или для извлечения определенных атрибутов из модели (например, при добавлении их в `Model` в методе, аннотированном `@ModelAttribute`, выполняющимся перед каждым `@RequestMapping` методом в контроллере). Эта аннотация применяется как к методам, так и к параметрам метода. Пример использования для метода: 
```java 
@ModelAttribute public void populateModel(Model model) { 
model.addAttribute("attributeName", "attributeValue"); 
} 
@GetMapping("/example") public String exampleMethod(@ModelAttribute("userForm") User user) { // Логика использования объекта user, связанного с полями формы 
return "userView"; 
} 
``` 
Используя `@ModelAttribute` перед параметром метода, Spring автоматически связывает параметры запроса с полями объекта. 
### @RequestParam
Аннотация `@RequestParam` служит для извлечения значения одного конкретного параметра в HTTP запросе и использования его в методе контроллера. Проще говоря, она используется для доступа к значениям запроса полями по ключам. Пример использования: 
```java
@GetMapping("/greeting") public String greeting(@RequestParam(name = "name", required = false, defaultValue = "World") String name, Model model) { 
model.addAttribute("name", name);
return "greeting";
} 
```
Аннотация `@RequestParam` более гибка по сравнению с `@ModelAttribute`, так как позволяет указать необязательные параметры с значение по умолчанию и более детально управлять обработкой запросов. 

### Заключение 
Используйте `@ModelAttribute` для связывания полей форм данных с объектом модели или для добавления общих атрибутов в модель. Аннотация полезна при работе с формами и когда входящие данные представляют собой сложный объект. Используйте `@RequestParam`, когда нужно просто получить значение одного параметра запроса. Это удобно, когда вы работаете с простыми типами данных или когда нужно извлечь одиночные значения из параметров строки запроса.


## ДОПОЛНЕНИЕ(на данном этапе - опционально)
## Q
- Чем фреймворк отличается от библиотеки? 
## A
Фреймворки и библиотеки - это оба наборы предварительно написанных кодов, которые используются для упрощения разработки программного обеспечения. Однако они отличаются по своему уровню контроля над потоком выполнения программы.

  

**Библиотека** - это набор функций и методов, которые можно напрямую вызывать из вашего кода. Когда вы используете библиотеку, вы контролируете поток выполнения программы. Вы решаете, когда и как использовать библиотеку. Библиотеки обычно ориентированы на решение конкретных задач, например работы с датами, HTTP-запросами, математическими операциями и т.д.


**Фреймворк**, с другой стороны, это не только коллекция библиотек для специфичной области (например, веб-разработка или тестирование), но и механизм управления потоком выполнения. Когда вы используете фреймворк, он определяет структуру вашего приложения и управляет потоком управления. Фреймворк вызывает ваш код при определенных событиях. Это часто называют "обратным управлением" или "инверсией управления".

  

Другими словами, основное отличие между фреймворками и библиотеками заключается в том, кто контролирует поток выполнения. Когда вы используете библиотеку, ваш код запускает и управляет вызовом. Когда вы используете фреймворк, он запускает и управляет вашим кодом.
## Q
19.  Уметь рассказать про принципы работы Spring
    
## A

По сути Spring Framework представляет собой просто контейнер внедрения зависимостей и может быть рассмотрен как коллекция меньших фреймворков или фреймворков во фреймворке. Большинство этих фреймворков может работать независимо друг от друга, однако они обеспечивают большую функциональность при совместном их использовании. Эти фреймворки делятся на структурные элементы типовых комплексных приложений:


1. Inversion of Control - контейнер (Core): делегированное (фреймворку) конфигурирование компонентов приложений и управление жизненным циклом Java-объектов.
    
2. Фреймворк аспектно-ориентированного программирования (AOP): работает с функциональностью, которая не может быть реализована возможностями объектно-ориентированного программирования на Java без потерь.
    
3. Фреймворк доступа к данным (Data Access/Integration): работает с системами управления реляционными базами данных на Java-платформе, используя JDBC- и ORM-средства и обеспечивая решения задач, которые повторяются в большом числе Java-based environments.
    
4. Фреймворк управления транзакциями: координация различных API управления транзакциями и инструментарий настраиваемого управления транзакциями для объектов Java.
    
5. Фреймворк MVC (Web): каркас, основанный на HTTP и сервлетах, предоставляющий множество возможностей для расширения и настройки (customization).
    
6. Фреймворк удалённого доступа: конфигурируемая передача Java-объектов через сеть в стиле RPC, поддерживающая RMI, CORBA, HTTP-based протоколы, включая web-сервисы (SOAP).
    
7. Фреймворк аутентификации и авторизации: конфигурируемый инструментарий процессов аутентификации и авторизации, поддерживающий много популярных и ставших индустриальными стандартами протоколов, инструментов, практик через дочерний проект Spring Security (ранее известный как Acegi).
    
8. Фреймворк удалённого управления: конфигурируемое представление и управление Java-объектами для локальной или удалённой конфигурации с помощью JMX.
    
9. Фреймворк работы с сообщениями (Messaging): конфигурируемая регистрация объектов-слушателей сообщений для прозрачной обработки сообщений из очереди сообщений с помощью JMS, улучшенная отправка сообщений по стандарту JMS API.
    
10. Тестирование (test): каркас, поддерживающий классы для написания модульных и интеграционных тестов.
    
## Q
Жизненный цикл контейнера

## A

    
2. Этап запуска (start) - вызывается методом `ApplicationContext#start`
    
3. Этап остановки (stop) - вызывается методом `ApplicationContext#stop`
    
4. Этап закрытия (close) - автоматический

# ИЛИ


Стоит знать

2. `ApplicationContext` вызывает метод `BeanFactoryPostProcessor#postProcessBeanFactory`
    
3. `BeanFactory` creates `BeanPostProcessor`-ы
    

Стоит знать

4. `ApplicationContext` регистрирует `BeanPostProcessor`-ы
    
5. Инициализация **singleton** bean-компонентов. Подробности в Жизненный цикл bean-компонента.
    
6. `ApplicationContext` проверяет флаг `SmartLifecycle#isRunning` и вызывает метод `SmartLifecycle#start`, если флаг имеет значение `false`
    

Стоит знать

7. `ApplicationContext` публикует `ContextRefreshedEvent`
    
8. Методы обратного вызова, помеченные аннотацией `@EventListener` с типом параметра метода `ContextRefreshedEvent`, обрабатывают это событие. Также здесь может быть `ApplicationListener`
    

#### Этап запуска контекста

1. `ApplicationContext` проверяет флаг `Lifecycle#isRunning` и вызывает метод `Lifecycle#start`, если флаг имеет значение false
    
2. `ApplicationContext` проверяет флаг `SmartLifecycle#isRunning` и вызывает метод `SmartLifecycle#start`, если флаг имеет значение false. Да-да, контекст второй раз проходиться по объектам реализующие интерфейс `SmartLifecycle`
    
3. `ApplicationContext` публикует `ContextStartedEvent`
    
4. Методы обратного вызова, помеченные аннотацией `@EventListener` с типом параметра метода `ContextStartedEvent`, обрабатывают это событие. Также здесь может быть `ApplicationListener`
    

#### Этап остановки контекста

1. `ApplicationContext` проверяет флаг `SmartLifecycle#isRunning` и вызывает метод `SmartLifecycle#stop`, если флаг имеет значение true
    
2. `ApplicationContext` проверяет флаг `Lifecycle#isRunning` и вызывает метод `Lifecycle#stop`, если флаг имеет значение true
    
3. `ApplicationContext` публикует `ContextStoppedEvent`
    
4. Методы обратного вызова, помеченные аннотацией `@EventListener` с типом параметра метода `ContextStoppedEvent`, обрабатывают это событие. Также здесь может быть `ApplicationListener`
    

#### Этап закрытия контекста

1. `ApplicationContext` публикует `ContextClosedEvent`
    
2. Методы обратного вызова, помеченные аннотацией `@EventListener` с типом параметра метода `ContextClosedEvent`, обрабатывают это событие. Также здесь может быть `ApplicationListener`
    
3. `ApplicationContext` проверяет флаг `SmartLifecycle#isRunning` и вызывает метод `SmartLifecycle#stop`, если флаг имеет значение `true`
    

Стоит знать

4. `ApplicationContext` проверяет флаг `Lifecycle#isRunning` и вызывает метод `Lifecycle#stop`, если флаг имеет значение `true`
    

Стоит знать

5. Уничтожение bean-компонентов. Подробности в Жизненный цикл bean-компонента
    

### Жизненный цикл bean-компонента

Жизненный цикл bean-компонента состоит из 2-ух этапов:

1. Этап инициализации
    
2. Этап уничтожения
    

#### Этап инициализации bean-компонента

1. `BeanFactory` создает bean-компонент
    
2. Срабатывает статический блок инициализации
    
3. Срабатывает не статический блок инициализации
    
4. Внедрение зависимостей на основе конструктора
    
5. Внедрение зависимостей на основе `setter`-ов
    

Стоит знать

6. Отрабатывают методы стандартного набора `*Aware` интерфейсов
    
7. `BeanPostProcessor#postProcessBeforeInitialization` обрабатывает bean-компонент
    
8. `InitDestroyAnnotationBeanPostProcessor#postProcessBeforeInitialization` вызывает методы обратного вызова, помеченные аннотацией `@PostConstruct`
    
9. `BeanFactory` вызывает метод `InitializingBean#afterPropertiesSet`
    
10. `BeanFactory` вызывает метод обратного вызова, зарегистрированный как `initMethod`
    
11. `BeanPostProcessor#postProcessAfterInitialization` обрабатывает bean-компонент
    

#### Этап уничтожения bean-компонента

Этап уничтожения срабатывает только для **singleton** bean-компонентов, так как только эти компоненты храниться в `BeanFactory`.

1. `InitDestroyAnnotationBeanPostProcessor.postProcessBeforeDestruction` вызывает методы обратного вызова, отмеченные как`@PreDestroy`
    
2. `BeanFactory` вызывает метод `InitializingBean#destroy`
    
3. `BeanFactory` вызывает метод обратного вызова, зарегистрированный как `destroyMethod`

Сначала идёт запуск
`ClassPathXmlApplicationContext` или аннотацию `@SpringBootApplication`
1. **Инициализация:** Контейнер Spring создается, инициализируется и начинает создание экземпляров бинов и проведение их конфигурации. Это может произойти через XML-конфигурацию, Java-конфигурацию или аннотации.
    
2. **Предоставление свойств бинов:** Контейнер конфигурирует свойства каждого бина с учетом конфигурации и вложенности. Это может включать в себя инициализацию полей данных и вызов методов установки.
    
3. **Внедрение зависимостей:** Контейнер внедряет зависимости в бины. Это может происходить через конструкторы, методы установки или поля.
    
4. **Инициализация бинов:** После того, как все свойства и зависимости установлены, контейнер вызывает инициализирующие методы бинов, если такие указаны.
    
5. **Использование бинов:** Готовые бины теперь доступны для использования в приложении.
    
6. **Завершение работы бинов:** Когда контейнер закрывается, он вызывает методы деструктуризации или "destroy-methods" для каждого бина, если такие указаны. Это дает бинам возможность освободить ресурсы и выполнить любую необходимую очистку.
    
7. **Уничтожение контейнера:** В конце жизненного цикла контейнер уничтожается вместе со всеми бинами.

## Q
20.  Связывание бинов и их жизненный цикл.
    
## A
Через следующие этапы проходит каждый отдельно взятый бин:
С учетом ваших добавлений, полный жизненный цикл бина в Spring Framework будет следующим: 
1. **Инстанцирование объекта (техническое начало жизни бина):** Работа конструктора его класса, создание экземпляра бина. 
2. **Установка свойств из конфигурации бина:** После создания экземпляра, Spring устанавливает все свойства, указанные в конфигурационном файле или с помощью аннотаций. 
3. **Вызов метода `postProcessBeforeInitialization()` интерфейса `BeanPostProcessor`:** Пре-инициализация бина перед вызовом инициализации. 
4. **Инициализация бина:**
- Вызов метода бина с аннотацией `@PostConstruct`; 
- Вызов метода `afterPropertiesSet()` для бинов, реализующих интерфейс `InitializingBean` (если метод есть); 
- Вызов пользовательского init-метода (указанного в параметре `initMethod`). 
1. **Вызов метода `postProcessAfterInitialization()` интерфейса `BeanPostProcessor`:** Пост-инициализация бина после окончания его инициализации. После этих этапов бин полностью инициализирован и готов к использованию в приложении. По окончании работы приложения и уничтожении контекста происходят этапы завершения работы бина: 
2. **Вызов метода `destroy()`:** Для бинов, реализующих интерфейс `DisposableBean`. 
3. **Вызов произвольного метода уничтожения:** Указанного в параметре `destroyMethod`. 
4. **Вызов метода с аннотацией `@PreDestroy`:** Этот метод вызывается перед уничтожением бина для очистки ресурсов. Эти шаги обеспечивают корректное создание, конфигурирование, использование и уничтожение бинов в контейнере Spring.
![[Pasted image 20240503175352.png]]
6. **![[102 all-slides.pdf]]